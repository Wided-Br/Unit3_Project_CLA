 1/1:
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
 1/2:
# generating synthetic data using make_blobs method
random_state=1
X,y = make_blobs(n_samples=1000, centers=5, n_features=2, random_state=random_state)
print(X.shape, y.shape)
 1/3: plt.scatter(X[:, 0], X[:, 1])
 1/4:
plt.scatter(X[:, 0], X[:, 1])
plt.show()
 1/5:
y_pred = KMeans(n_cluster=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
 1/6:
y_pred = KMeans(n_clusters=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
 1/7:
y_pred = KMeans(n_clusters=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
 1/8:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_cluster=k)
    kmeans.fit(X)
    distorsions.append(kmeans.inertia_)

fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid=True
plt.title = "Elbow Curve"
 1/9:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(X)
    distorsions.append(kmeans.inertia_)

fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid=True
plt.title = "Elbow Curve"
1/10:
y_pred = KMeans(n_clusters=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
1/11:
y_pred = KMeans(n_clusters=5, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
 2/1:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import Kmeans
 2/2:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
 2/3: df = pd.read_csv("clustering_data.csv")
 2/4:
df = pd.read_csv("clustering_data.csv")
df.info()
 4/1:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
 4/2:
df = pd.read_csv("clustering_data.csv")
df.info()
 4/3: df.head()
 4/4: plt.scatter(df[:,0], df[:,1])
 4/5: plt.scatter(df[0], df[1])
 4/6:
plt.scatter(df[0], df[1])
plt.show()
 4/7:
plt.scatter(df[1], df[1])
plt.show()
 4/8: df
 4/9:
plt.scatter(df.iloc[0], df.iloc[1])
plt.show()
4/10:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
4/11:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plt(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
4/12:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
4/13:
y_pred = KMeans(n_clusters=5, init='random', random_state=random_state).fit_predict(df)
plt.scatter(df.iloc[:,0], df.ilov[:,1], c=y_pred)
plt.show()
4/14:
y_pred = KMeans(n_clusters=5, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.ilov[:,1], c=y_pred)
plt.show()
4/15:
y_pred = KMeans(n_clusters=5, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
4/16:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
4/17: !jt -l
4/18: !jt -t oceans16
 5/1: !jt -l
 5/2: !jt -t oceans16
 5/3:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
 5/4:
df = pd.read_csv("clustering_data.csv")
df.info()
 5/5: df
 5/6:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
 5/7:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
 5/8:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
 5/9: !jt -t chesterish
 6/1: !jt -l
 6/2: !jt -t chesterish
 6/3:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
 6/4:
df = pd.read_csv("clustering_data.csv")
df.info()
 6/5: df
 6/6:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
 6/7:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
 6/8:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
 7/1: !jt -t oceans16
 9/1: !jt -l
 9/2: !jt -t oceans16
 9/3:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
 9/4:
df = pd.read_csv("clustering_data.csv")
df.info()
 9/5: df
 9/6:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
 9/7:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
 9/8:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
10/1: !jt -r
10/2: !jt -r
11/1: !jt -r
11/2:
# importing the necessary packages
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
11/3:
# generating synthetic data using make_blobs method
random_state=1
X,y = make_blobs(n_samples=1000, centers=5, n_features=2, random_state=random_state)
print(X.shape, y.shape)
11/4:
plt.scatter(X[:, 0], X[:, 1])
plt.show()
11/5:
y_pred = KMeans(n_clusters=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
11/6:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(X)
    distorsions.append(kmeans.inertia_)

fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid=True
plt.title = "Elbow Curve"
11/7:
y_pred = KMeans(n_clusters=5, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
12/1:
# importing the necessary packages
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
12/2:
# generating synthetic data using make_blobs method
random_state=1
X,y = make_blobs(n_samples=1000, centers=5, n_features=2, random_state=random_state)
print(X.shape, y.shape)
12/3:
plt.scatter(X[:, 0], X[:, 1])
plt.show()
12/4:
y_pred = KMeans(n_clusters=2, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
12/5:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(X)
    distorsions.append(kmeans.inertia_)

fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid=True
plt.title = "Elbow Curve"
12/6:
y_pred = KMeans(n_clusters=5, init='random', random_state=random_state).fit_predict(X)
plt.scatter(X[:,0], X[:,1], c=y_pred)
plt.show()
14/1:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
14/2:
df = pd.read_csv("clustering_data.csv")
df.info()
14/3: df
14/4:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
14/5:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
14/6:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
15/1:
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
15/2:
df = pd.read_csv("clustering_data.csv")
df.info()
15/3: df.head()
15/4:
plt.scatter(df.iloc[:, 0], df.iloc[:, 1])
plt.show()
15/5:
distorsions = []
for k in range(2,20):
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df)
    distorsions.append(kmeans.inertia_)
    
fig = plt.figure(figsize = (15,5))
plt.plot(range(2,20), distorsions)
plt.grid = True
plt.title = "Elbow curve"
15/6:
y_pred = KMeans(n_clusters=6, init='random', random_state=1).fit_predict(df)
plt.scatter(df.iloc[:,0], df.iloc[:,1], c=y_pred)
plt.show()
16/1:
from sklearn.datasets import load_breast_cancer
from sklearn.ensemble import RandomForrestClassifier

from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import LeaveOneOut

from sklearn import metrics
import numpy as np
16/2:
from sklearn.datasets import load_breast_cancer
from sklearn.ensemble import RandomForestClassifier

from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import LeaveOneOut

from sklearn import metrics
import numpy as np
16/3:
from sklearn.datasets import load_breast_cancer
from sklearn.ensemble import RandomForestClassifier

from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import LeaveOneOut

from sklearn import metrics
import numpy as np
16/4: X, y = load_breast_cancer(return_X_y = True)
16/5:
# Creating the random forest classifier using 10 decision trees and the entropy criterion
clf = RnadomForestClassifier(n_estimators=10, criterion='entropy', random_state=0)
16/6:
# Creating the random forest classifier using 10 decision trees and the entropy criterion
clf = RandomForestClassifier(n_estimators=10, criterion='entropy', random_state=0)
16/7:
# The Holdout Method
X_train, X_train, y_train, y_test = train_test_split(X,y, test_size = 0.2, random_state=0)
clf = clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
print("Accuracy = ", metrics.accuracy_score(y_test, y_pred))
16/8:
# The Holdout Method
X_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2, random_state=0)
clf = clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)
print("Accuracy = ", metrics.accuracy_score(y_test, y_pred))
16/9:
# KFold Cross Validation
kf = KFold(n_splits=5)
accuracies = []
for train_index, text_index in kf.split(X):
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]
    clf = clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    accuracies.append(metrics.accuracy_score(y_test, y_pred))
print("Cross validation accuracy = ", np.mean(accuracies))
16/10:
# KFold Cross Validation
kf = KFold(n_splits=5)
accuracies = []
for train_index, test_index in kf.split(X):
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]
    clf = clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    accuracies.append(metrics.accuracy_score(y_test, y_pred))
print("Cross validation accuracy = ", np.mean(accuracies))
16/11:
# KFold Cross Validation
kf = KFold(n_splits=5)
accuracies = []
for train_index, test_index in kf.split(X):
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]
    clf = clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    accuracies.append(metrics.accuracy_score(y_test, y_pred))
print(accuracies)
print("Cross validation accuracy = ", np.mean(accuracies))
16/12:
# LeaveOneOut cross validation
loo = LeaveOneOut()
accuracies = []
for train_index, test_index in loo.split(X):
    X_train, X_test = X[train_index], X[test_index]
    y_train, y_test = y[train_index], y[test_index]
    clf = clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    accuracies.append(metrics.accuracy_score(y_test, y_pred))
print(accuracies)
print("LeaveOneOut accuracy = ", np.mean(accuracies))
17/1:
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.model_selection import test_train_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
17/2:
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
17/3:
# Load the data and split it into train and test
data = load_breast_cancer()
X = data.data
Y = data.target

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)
17/4:
# Set the parameters by cross validation
tuned_parameters = [{'Kernel':['rbf','linear'], 'gamma':[1e-3, 1e-4], 'C':[1,10,100,1000]}]
17/5:
def grid_search(X_train, y _train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_paramaeters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (/-%0.03f) for %r") % (mean, std*2, params)
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
17/6:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_paramaeters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (/-%0.03f) for %r") % (mean, std*2, params)
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/1:
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
18/2:
# Load the data and split it into train and test
data = load_breast_cancer()
X = data.data
Y = data.target

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)
18/3:
# Set the parameters by cross validation
tuned_parameters = [{'Kernel':['rbf','linear'], 'gamma':[1e-3, 1e-4], 'C':[1,10,100,1000]}]
18/4: scores = ["precision", "recall"]
18/5:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_paramaeters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (/-%0.03f) for %r") % (mean, std*2, params)
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/6:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
18/7:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_paramaeters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_parameters, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (/-%0.03f) for %r") % (mean, std*2, params)
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/8:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
18/9:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_parameters, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (+/-%0.03f) for %r" % (mean, std*2, params))
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/10:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
18/11:
# Load the data and split it into train and test
data = load_breast_cancer()
X = data.data
Y = data.target

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)
18/12:
# Set the parameters by cross validation
tuned_parameters = [{'Kernel':['rbf','linear'], 'gamma':[1e-3, 1e-4], 'C':[1,10,100,1000]}]
18/13: scores = [''precision', 'recall']
18/14: scores = ['precision', 'recall']
18/15:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_parameters, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (+/-%0.03f) for %r" % (mean, std*2, params))
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/16:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
18/17:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (+/-%0.03f) for %r" % (mean, std*2, params))
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
18/18:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
19/1:
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
19/2:
# Load the data and split it into train and test
data = load_breast_cancer()
X = data.data
Y = data.target

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)
19/3:
# Set the parameters by cross validation
tuned_parameters = [{'Kernel':['rbf','linear'], 'gamma':[1e-3, 1e-4], 'C':[10,100,1000]}]
19/4: scores = ['precision', 'recall']
19/5:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (+/-%0.03f) for %r" % (mean, std*2, params))
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
19/6:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
20/1:
from sklearn.datasets import load_breast_cancer
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report
20/2:
# Load the data and split it into train and test
data = load_breast_cancer()
X = data.data
Y = data.target

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 42)
20/3:
# Set the parameters by cross validation
tuned_parameters = [{'kernel':['rbf','linear'], 'gamma':[1e-3, 1e-4], 'C':[10,100,1000]}]
20/4: scores = ['precision', 'recall']
20/5:
def grid_search(X_train, y_train, X_test, y_test, tuned_params, metric="precision"):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(SVC(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
    print("Grid scores on development set: ")
    print(clf.best_estimator_)
    print()
    means = clf.cv_results_['mean_test_score']
    stds = clf.cv_results_['std_test_score']
    for mean, std, params in zip(means, stds, clf.cv_results_['params']):
        print("%0.3f (+/-%0.03f) for %r" % (mean, std*2, params))
        
    print("Classification report ")
    y_true, y_pred, = y_test, clf.predict(X_test)
    print(classification_report(y_true, y_pred))
20/6:
# Grid Search using only the precision
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[0])
20/7: grid_search(X_train, y_train, X_test, y_test, tuned_parameters, scores[1])
21/1:
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import autosklearn.classification as automl
23/1:
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import autosklearn.classification as automl
import warnings 
warnings.filterwarnings("ignore")
25/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, low, x, n)
    return -1
25/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, low, x, n)
    return -1
25/3:
def nb_occur(sorted_arr, x):
    n = sorted_arr.len()
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if i == -1:
        return i
    last = last_occ(sorted_arr, n-1, i, x,n)
    
    return (j-i+1)
25/4:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occ(data.sorted(), i) < n):
            res.append(i)
            
    return res
25/5: solution([1,2,3], 0)
25/6: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/7:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(data.sorted(), i) < n):
            res.append(i)
            
    return res
25/8: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/9:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) < n):
            res.append(i)
            
    return res
25/10: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/11:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if i == -1:
        return i
    last = last_occ(sorted_arr, n-1, i, x,n)
    
    return (j-i+1)
25/12:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) < n):
            res.append(i)
            
    return res
25/13: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/14:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/15:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if i == -1:
        return i
    last = last_occ(sorted_arr, n-1, i, x,n)
    
    return (j-i+1)
25/16:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) < n):
            res.append(i)
            
    return res
25/17: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/18:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/19:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/20:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if i == -1:
        return i
    last = last_occ(sorted_arr, n-1, i, x,n)
    
    return (j-i+1)
25/21:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) < n):
            res.append(i)
            
    return res
25/22: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/23:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    
    return (last-first+1)
25/24:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) < n):
            res.append(i)
            
    return res
25/25: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/26:
def solution(data, n):
    res = []
    if n==0:
        return []
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
25/27: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/28:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
25/29:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
25/30: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/31:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ((mid == 0 or x > arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/32:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/33:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
25/34:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
25/35: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
25/36:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ((mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/37:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < sorted_arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
25/38:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
25/39:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
25/40: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
26/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ((mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
26/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < sorted_arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
26/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
26/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
26/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
27/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ((mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
27/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < sorted_arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x < sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
27/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
27/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
27/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
28/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ((mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
28/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < sorted_arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x < sorted_arr[mid] ):
            return last_occ(sorted_arr, mid-1, inf, x, n)
        else:
            return last_occ(sorted_arr, sup, mid+1, x, n)
    return -1
28/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
28/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
28/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
29/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
29/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ( x == sorted_arr[mid] ):
            return mid
        elif ( x < sorted_arr[mid] ):
            return last_occ(sorted_arr, mid-1, inf, x, n)
        else:
            return last_occ(sorted_arr, sup, mid+1, x, n)
    return -1
29/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
29/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
29/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
30/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ( (mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
30/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x < sorted_arr[mid] ):
            return last_occ(sorted_arr, mid-1, inf, x, n)
        else:
            return last_occ(sorted_arr, sup, mid+1, x, n)
    return -1
30/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
30/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
30/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
31/1:
# first_occ returns the index of the the first occurence of x in a
# sorted array
def first_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf :
        mid = (sup + inf) // 2
        if ( (mid == 0 or x > sorted_arr[mid-1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x > sorted_arr[mid] ):
            return first_occ(sorted_arr, sup, mid+1, x, n)
        else:
            return first_occ(sorted_arr, mid-1, inf, x, n)
    return -1
31/2:
# last_occ returns the index of the the last occurence of x in a
# sorted array
def last_occ(sorted_arr, sup, inf, x, n):
    if sup >= inf:
        mid = (sup + inf) //2
        if ((mid == n-1 or x < sorted_arr[mid+1]) and x == sorted_arr[mid] ):
            return mid
        elif ( x < sorted_arr[mid] ):
            return last_occ(sorted_arr, mid-1, inf, x, n)
        else:
            return last_occ(sorted_arr, sup, mid+1, x, n)
    return -1
31/3:
def nb_occur(sorted_arr, x):
    n = len(sorted_arr)
    first = first_occ(sorted_arr, n-1, 0, x, n)
    if first == -1:
        return first
    last = last_occ(sorted_arr, n-1, first, x,n)
    print(last-first+1)
    return (last-first+1)
31/4:
def solution(data, n):
    res = []
    if n==0:
        return res
    for i in data:
        if (nb_occur(sorted(data), i) <= n):
            res.append(i)
            
    return res
31/5: solution([1, 2, 2, 3, 3, 3, 4, 5, 5], 1)
32/1:
def find_id(start, c, l):
    id = start; k = l+1
    for i in range(c):
        id = sum + k
        k = k+1
    return id
32/2:
def line_count_down(l):
    sum = 1; k = 1;
    for i in range (l):
        sum = sum + k
        k = k+1
    return sum
32/3:
def find_id(start, c, l):
    id = start; k = l+1
    for i in range(c):
        id = sum + k
        k = k+1
    return id
32/4:
def solution(x,y):
    return find_id(line_count_down, x, y)
32/5: solution(1,1)
32/6:
def line_count_down(l):
    sum = 1; k = 1;
    for i in range (l):
        sum = sum + k
        k = k+1
    return sum
32/7:
def find_id(start, c, l):
    id = start; k = l+1
    for i in range(c):
        id = id + k
        k = k+1
    return id
32/8:
def solution(x,y):
    return find_id(line_count_down, x, y)
32/9: solution(1,1)
32/10:
def line_count_down(l):
    sum = 1; k = 1;
    for i in range (l):
        sum = sum + k
        k = k+1
    return sum
32/11:
def find_id(start, c, l):
    id_ = start; k = l+1
    for i in range(c):
        id_ = id_ + k
        k = k+1
    return id_
32/12:
def solution(x,y):
    return find_id(line_count_down, x, y)
32/13: solution(1,1)
32/14:
def line_count_down(l):
    sum = 1; k = 1;
    for i in range (l):
        sum = sum + k
        k = k+1
    return sum
32/15:
def find_id(start, c, l):
    the_id = start; k = l+1
    for i in range(c):
        the_id = the_id + k
        k = k+1
    return the_id
32/16:
def solution(x,y):
    return find_id(line_count_down(y), x, y)
32/17: solution(1,1)
32/18:
def line_count_down(l):
    sum = 1; k = 1;
    for i in range (l-1):
        sum = sum + k
        k = k+1
    return sum
32/19:
def find_id(start, c, l):
    the_id = start; k = l+1
    for i in range(c-1):
        the_id = the_id + k
        k = k+1
    return the_id
32/20:
def solution(x,y):
    return find_id(line_count_down(y), x, y)
32/21: solution(1,1)
32/22: solution(3,2)
32/23: solution(2,3)
32/24: solution(5,4)
32/25:
def solution(x,y):
    return str(find_id(line_count_down(y), x, y))
32/26: solution(5,4)
33/1:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
def postorder(height, nums):
    if h == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
33/2:
height = 3
tree = postorder(height, list(range(1, 2 ** height)))
33/3:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
33/4:
height = 3
tree = postorder(height, list(range(1, 2 ** height)))
33/5: tree
33/6: tree.root
33/7: tree.right
33/8: tree.root
33/9:
tree.root.right
tree.root.left
33/10: tree.root.right
33/11: tree.root
33/12: tree.root()
33/13: tree->root
33/14: tree()root
33/15: tree(root)
33/16: root.left
33/17: tree.root.left
33/18: tree.root
33/19: tree.left
33/20: tree.left.left
33/21: tree.left.root
33/22: tree.right.root
33/23: tree.right.right.root
33/24:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
33/25:
height = 3
tree = postorder(height, list(range(1, 2 ** height)))
33/26: tree.right.right.root
33/27:
# A function to do postorder tree traversal
def printPostorder(root):
 
    if root:
 
        # First recur on left child
        printPostorder(root.left)
 
        # the recur on right child
        printPostorder(root.right)
 
        # now print the data of node
        print(root.root)
33/28: printPostorder(tree)
36/1:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
36/2:
height = 5
tree = postorder(height, list(range(1, 2 ** height)))
36/3:
# A function to do postorder tree traversal
def printPostorder(root):
 
    if root:
 
        # First recur on left child
        printPostorder(root.left)
 
        # the recur on right child
        printPostorder(root.right)
 
        # now print the data of node
        print(root.root)
36/4: printPostorder(tree)
36/5:
height = 3
tree = postorder(height, list(range(1, 2 ** height)))
36/6:
# A function to do postorder tree traversal
def printPostorder(root):
 
    if root:
 
        # First recur on left child
        printPostorder(root.left)
 
        # the recur on right child
        printPostorder(root.right)
 
        # now print the data of node
        print(root.root)
36/7: printPostorder(tree)
36/8:
height = 2
tree = postorder(height, list(range(1, 2 ** height)))
36/9:
# A function to do postorder tree traversal
def printPostorder(root):
 
    if root:
 
        # First recur on left child
        printPostorder(root.left)
 
        # the recur on right child
        printPostorder(root.right)
 
        # now print the data of node
        print(root.root)
36/10: printPostorder(tree)
38/1:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
38/2:
height = 3
tree = postorder(height, list(range(1, 2 ** height)))
38/3:
# A function to do postorder tree traversal
def printPostorder(root):
 
    if root:
 
        # First recur on left child
        printPostorder(root.left)
 
        # the recur on right child
        printPostorder(root.right)
 
        # now print the data of node
        print(root.root)
38/4: printPostorder(tree)
38/5:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return
 
    # If current node is
    # the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls
        # for the children
        # of the current node
        # Current node is now
        # the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
38/6: findParent(tree.root, 3, -1)
38/7: printPostorder(tree(1))
38/8: findParent(tree(1), 3, -1)
38/9: findParent(tree, 3, -1)
38/10: findParent(tree, 7, -1)
38/11: findParent(tree, 2, -1)
38/12: findParent(tree, 4, -1)
38/13: findParent(tree, 5, -1)
38/14: findParent(tree, 7, -1)
38/15:
height = 5
tree = postorder(height, list(range(1, 2 ** height)))
38/16:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return
 
    # If current node is
    # the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls
        # for the children
        # of the current node
        # Current node is now
        # the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
38/17: findParent(tree, 7, -1)
38/18: findParent(tree, 19, -1)
38/19: findParent(tree, 14, -1)
38/20: findParent(tree, 28, -1)
38/21: findParent(tree, 31, -1)
39/1:
class Node:
    def __init__(self, root):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
39/2:
height = 5
tree = postorder(height, list(range(1, 2 ** height)))
39/3:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
39/4:
height = 5
tree = postorder(height, list(range(1, 2 ** height)))
39/5:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/6: findParent(tree,28, -1)
39/7:
height = 1
tree = postorder(height, list(range(1, 2 ** height)))
39/8:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/9:
height = 1
tree = postorder(height, list(range(1, 2 ** height)))
39/10:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/11: findParent(tree,28, -1)
39/12: findParent(tree,28, -1)
39/13: findParent(tree,1, -1)
39/14:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/15: findParent(tree,14, -1)
39/16: findParent(tree,14, -1)
39/17:
height = 2
tree = postorder(height, list(range(1, 2 ** height)))
39/18:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/19: findParent(tree,14, -1)
39/20:
def findParent(node : Node, val : int, parent : int) -> -1:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/21: findParent(tree,14, -1)
39/22:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return (-1)
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/23: findParent(tree,14, -1)
39/24:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
       
        # Print its parent
        print(parent)
    else:
       
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/25: findParent(tree,14, -1)
39/26:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return parent
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/27: findParent(tree,14, -1)
39/28:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/29: findParent(tree,14, -1)
39/30:
def solution(h, q):
    tree = postorder(height, list(range(1, 2 ** h)))
    p = []
    for node in q:
        p.append(findParent(tree, node, -1))
39/31: solution(5, [19, 14, 28])
39/32:
def solution(h, q):
    tree = postorder(height, list(range(1, 2 ** h)))
    p = []
    for node in q:
        p.append(findParent(tree, node, -1))
    return p
39/33: solution(5, [19, 14, 28])
39/34:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
39/35:
def solution(h, q):
    tree = postorder(height, list(range(1, 2 ** h)))
    p = []
    for node in q:
        p.append(findParent(tree, node, -1))
    return p
39/36: solution(5, [19, 14, 28])
39/37:
def solution(h, q):
    tree = postorder(height, list(range(1, 2 ** h)))
    p = []
    for item in q:
        p.append(findParent(tree, item, -1))
    return p
39/38: solution(5, [19, 14, 28])
39/39:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        p.append(findParent(tree, item, -1))
    return p
39/40: solution(5, [19, 14, 28])
39/41:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        p.append(findParent(tree, item, -1))
    return p
39/42: solution(5, [19, 14, 28])
39/43:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        p.append(parent)
    return p
39/44: solution(5, [19, 14, 28])
40/1:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
40/2:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
40/3:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        p.append(parent)
    return p
40/4: solution(5, [19, 14, 28])
40/5:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
40/6: solution(5, [19, 14, 28])
40/7:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
40/8:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
40/9: solution(5, [19, 14, 28])
41/1:
class Node:
    def __init__(self, root=None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
41/2:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/3:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/4: solution(5, [19, 14, 28])
41/5:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/6:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/7: solution(5, [19, 14, 28])
41/8:
def findParent(node : Node, val : int, parent : int) -> None:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/9:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/10: solution(5, [19, 14, 28])
41/11:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/12:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/13: solution(5, [19, 14, 28])
41/14:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/15:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/16: solution(5, [19, 14, 28])
41/17:
def findParent(node : Node, val : int, parent : int):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/18:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        parent = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/19: solution(5, [19, 14, 28])
41/20:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(parent)
        p.append(parent)
    return p
41/21:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/22: solution(5, [19, 14, 28])
41/23:
def findParent(node : Node, val : int, parent : int):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/24:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/25: solution(5, [19, 14, 28])
41/26:
def findParent(node : Node, val : int, parent : int):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(node.root)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/27:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/28: solution(5, [19, 14, 28])
41/29:
def findParent(node : Node, val : int, parent : int):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/30:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/31: solution(5, [19, 14, 28])
41/32:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/33:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/34: solution(5, [19, 14, 28])
41/35:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
    return node.root
41/36:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/37: solution(5, [19, 14, 28])
41/38:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
    return node.root
41/39:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/40: solution(5, [19, 14, 28])
41/41:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
    return parent
41/42:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/43: solution(5, [19, 14, 28])
41/44:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/45:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/46: solution(5, [19, 14, 28])
41/47:
class Node:
    def __init__(self, root):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
41/48:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/49:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/50: solution(5, [19, 14, 28])
41/51:
class Node:
    def __init__(self, root):
        self.root = None
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
41/52:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/53:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/54: solution(5, [19, 14, 28])
41/55:
class Node:
    def __init__(self, root = None):
        self.root = root
        self.left = self.right = None
        
def postorder(height, nums):
    if height == 1:
        return Node(nums.pop())
    node = Node()
    node.root = nums.pop()
    node.right = postorder(height-1, nums)
    node.left = postorder(height-1, nums)
    return node
41/56:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/57:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/58: solution(5, [19, 14, 28])
41/59:
def findParent(node : Node, val : int, parent : int) -> Node:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/60:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/61: solution(5, [19, 14, 28])
41/62:
def findParent(node : Node, val : int, parent : int) -> parent:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/63:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/64: solution(5, [19, 14, 28])
41/65:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/66:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/67: solution(5, [19, 14, 28])
41/68:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/69:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/70: solution(5, [19, 14, 28])
41/71:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/72:
def findParent(node : Node, val : int, parent : int) -> int:
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/73:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/74:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/75:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/76:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/77:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/78:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
41/79:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/80:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/81:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        return parent
        findParent(node.right, val, node.root)
        return parent
41/82:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/83:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/84:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        p = parent
        print(p)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        findParent(node.left, val, node.root)
        findParent(node.right, val, node.root)
        
    return p
41/85:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/86:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/87:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
41/88:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/89:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/90:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
41/91:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/92:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/93:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/94:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/95:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/96:
def findParent(node, val, parent):
    if (node is None):
        return 
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        #print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/97:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/98:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/99:
def findParent(node, val, parent):
    if (node is None):
        return parent
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        #print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/100:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/101:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/102:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        #print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/103:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/104:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/105:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        #print(parent)
        #return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/106:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
        #return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/107:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/108:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/109:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        print(parent)
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
    return parent
41/110:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/111:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/112:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        s= print(parent)
        return s
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
41/113:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/114:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/115:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        s = print(parent)
        return int(s)
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
41/116:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/117:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/118:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return int(print(parent))
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        parent = findParent(node.right, val, node.root)
41/119:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/120:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/121:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return parent
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        parent = findParent(node.left, val, node.root)
        return parent
        parent = findParent(node.right, val, node.root)
        return parent
41/122:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/123:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/124:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        node.root = findParent(node.left, val, node.root)
        node.root = findParent(node.right, val, node.root)
41/125:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/126:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/127:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        node.root = findParent(node.left, val, node.root)
        node.root = findParent(node.right, val, node.root)
        
    return node.root
41/128:
def solution(h, q):
    tree = postorder(h, list(range(1, 2 ** h)))
    p = []
    for item in q:
        i = findParent(tree, item, -1)
        print(i)
        p.append(i)
    return p
41/129:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2, -1)
41/130:
def findParent(node, val, parent):
    if (node is None):
        return -1
 
    # If current node is the required node
    if (node.root == val):
        # Print its parent
        return node.root
    else:
        # Recursive calls for the children of the current node 
        # Current node is now the new parent
        node.root = findParent(node.left, val, node.root)
        node.root = findParent(node.right, val, node.root)
        
    return node.root
41/131:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/132:
def findParent(node, val):
    if (node == null || node.root == key):
        return -1
    if ((node.left != null && node.left.root == key) || (node.right != null && node.right.root == key)):
        return node
    Node l = getParent(node.left, key)
    if (l != null):
        return l
    l = getParent(node.right, key)
    return l
41/133:
def findParent(node, val):
    if (node == null or node.root == key):
        return -1
    if ((node.left != null && node.left.root == key) || (node.right != null && node.right.root == key)):
        return node
    Node l = getParent(node.left, key)
    if (l != null):
        return l
    l = getParent(node.right, key)
    return l
41/134:
def findParent(node, val):
    if (node == null or node.root == key):
        return -1
    if ((node.left != null and node.left.root == key) or (node.right != null and node.right.root == key)):
        return node
    Node l = getParent(node.left, key)
    if (l != null):
        return l
    l = getParent(node.right, key)
    return l
41/135:
def findParent(node, val):
    if (node == null or node.root == key):
        return -1
    if ((node.left != null and node.left.root == key) or (node.right != null and node.right.root == key)):
        return node
    l = getParent(node.left, key)
    if (l != null):
        return l
    l = getParent(node.right, key)
    return l
41/136:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/137:
def findParent(node, val):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        return node
    l = getParent(node.left, key)
    if (l != None):
        return l
    l = getParent(node.right, key)
    return l
41/138:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/139:
def findParent(node, key):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        return node
    l = getParent(node.left, key)
    if (l != None):
        return l
    l = getParent(node.right, key)
    return l
41/140:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/141:
def findParent(node, key):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        return node
    l = findParent(node.left, key)
    if (l != None):
        return l
    l = findParent(node.right, key)
    return l
41/142:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/143:
def findParent(node, key):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        return node.root
    l = findParent(node.left, key)
    if (l != None):
        return l.root
    l = findParent(node.right, key)
    return l.root
41/144:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/145:
def findParent(node, key):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        return node
    l = findParent(node.left, key)
    if (l != None):
        return l
    l = findParent(node.right, key)
    return l
41/146:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
41/147:
tree = postorder(3, list(range(1, 2**3)))
print(findParent(tree, 2))
41/148:
def findParent(node, key):
    if (node == None or node.root == key):
        return -1
    if ((node.left != None and node.left.root == key) or (node.right != None and node.right.root == key)):
        print(node)
    l = findParent(node.left, key)
    if (l != None):
        print(l)
    l = findParent(node.right, key)
    print(l)
41/149:
tree = postorder(3, list(range(1, 2**3)))
findParent(tree, 2)
42/1:
import math
 
# Function to find the parent
# of the given node
def findParent(height, node):
 
    start = 1
    end = pow(2, height) - 1
 
    # Check whether the given node
    # is a root node.if it is then
    # return -1 because root
    # node has no parent
    if (end == node):
        return -1
 
    # Loop till we found
    # the given node
    while(node >= 1):
 
        end = end - 1
 
        # Find the middle node of the
        # tree because at every level
        # tree parent is divided
        # into two halves
        mid = start + (end - start)//2
 
        # if the node is found
        # return the parent
        # always the child nodes of every
        # node is node / 2 or (node-1)
        if(mid == node or end == node):
            return (end + 1)
         
        # if the node to be found is greater
        # than the mid search for left
        # subtree else search in right subtree
        elif (node < mid):
            end = mid
 
        else:
            start = mid
 
# Driver code
if __name__ == "__main__":
    height = 4
    node = 6
     
    # Function Call
    k = findParent(height, node)
    print(k)
42/2:
def solution(h, q):
    p=[]
    for node in q:
        p.append(findParent(h, node))
    return p
42/3: solution(5, [19, 14, 28])
42/4:
def findParent(height, node):
    start = 1
    end = (2**height) -1
    if (end == node):
        return -1
    while(node >= 1):
        end = end - 1
        mid = start + (end - start)//2
        if(mid == node or end == node):
            return (end + 1)
        elif (node < mid):
            end = mid
        else:
            start = mid
42/5:
def solution(h, q):
    p=[]
    for node in q:
        p.append(findParent(h, node))
    return p
42/6: solution(5, [19, 14, 28])
43/1: solution(5, [19, 14, 25])
43/2:
def findParent(height, node):
    start = 1
    end = (2**height) -1
    if (end == node):
        return -1
    while(node >= 1):
        end = end - 1
        mid = start + (end - start)//2
        if(mid == node or end == node):
            return (end + 1)
        elif (node < mid):
            end = mid
        else:
            start = mid
43/3:
def solution(h, q):
    p=[]
    for node in q:
        p.append(findParent(h, node))
    return p
43/4: solution(5, [19, 14, 25])
43/5: solution(5, [19, 14, 26])
43/6: solution(5, [19, 15, 26])
43/7: solution(5, [16, 29, 26])
43/8: solution(5, [16, 29, 15])
43/9:
def findParent(height, node):
    start = 1
    end = (2**height) -1
    if (end == node):
        return -1
    while(node >= 1):
        end = end - 1
        mid = (start + end) //2
        if(mid == node or end == node):
            return (end + 1)
        elif (node < mid):
            end = mid
        else:
            start = mid
43/10:
def solution(h, q):
    p=[]
    for node in q:
        p.append(findParent(h, node))
    return p
43/11: solution(5, [16, 29, 15])
45/1: math.log2(35)
45/2:
import math
math.log2(35)
45/3:
import math
math.log2(32)
45/4:
import math
int res = math.log2(32)
print(res)
45/5:
import math
int res = math.log2(32);
print(res)
45/6:
import math
res = math.log2(32);
print(int(res))
45/7:
import math
res = math.log2(35);
print(int(res))
45/8:
import math
res = math.log2(32);
print(int(res))
45/9:
import math
res = math.log2(32);
print(res)
45/10: isPowerof2(36)
45/11:
def isPowerof2(n):
    return (math.ceil(log2(n)) == math.floor(log2(n)))
45/12: isPowerof2(36)
45/13:
import math
def isPowerof2(n):
    return (math.ceil(log2(n)) == math.floor(log2(n)))
45/14: isPowerof2(36)
45/15:
import math
def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))
45/16: isPowerof2(36)
45/17: isPowerof2(32)
45/18: isPowerof2(16)
45/19: isPowerof2(512)
45/20: isPowerof2(513)
45/21: isPowerof2(7512)
45/22: isPowerof2(2002)
45/23:
def isodd(n):
     if (num % 2) != 0:
            return true
45/24:
def isodd(n):
     if (num % 2) != 0:
            return True
45/25:
def iseven(n):
     if (num % 2) == 0:
            return True
45/26:
import math
def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))
45/27:
def isodd(n):
     if (num % 2) != 0:
            return True
45/28:
def iseven(n):
     if (num % 2) == 0:
            return True
45/29:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
    if isodd(n):
        nb_steps_p = count_steps(n+1)
        nb_steps_m = count_steps(n-1)
        return min(nb_steps_p, nb_steps_m)
45/30: count_steps(15)
45/31:
import math
def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))
45/32:
def isodd(n):
     if (n % 2) != 0:
            return True
45/33:
def iseven(n):
     if (n % 2) == 0:
            return True
45/34:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
    if isodd(n):
        nb_steps_p = count_steps(n+1)
        nb_steps_m = count_steps(n-1)
        return min(nb_steps_p, nb_steps_m)
45/35: count_steps(15)
45/36:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
        return nb_steps
    if isodd(n):
        nb_steps_p = count_steps(n+1)
        nb_steps_m = count_steps(n-1)
        return min(nb_steps_p, nb_steps_m)
45/37: count_steps(15)
45/38: count_steps(1)
45/39: count_steps(16)
45/40: count_steps(32)
45/41: count_steps(15)
45/42: count_steps(14)
45/43:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
        return nb_steps
    if isodd(n):
        nb_steps_p = count_steps(n+1)
        nb_steps_m = count_steps(n-1)
    return min(nb_steps_p, nb_steps_m)
45/44: count_steps(14)
45/45:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps_p + count_steps(n+1)
        nb_steps_m = nb_steps_m + count_steps(n-1)
    return min(nb_steps_p, nb_steps_m)
45/46: count_steps(14)
45/47:
import math
def count_steps(n):
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        nb_steps = count_steps(n/2)
        return nb_steps
    if isodd(n):
        nb_steps_p = count_steps(n+1)
        nb_steps_m = count_steps(n-1)
    return min(nb_steps_p, nb_steps_m)
45/48: count_steps(14)
45/49:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        return count_steps(n)
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
    return count_steps(n)
45/50: count_steps(14)
45/51:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        count_steps(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        count_steps(n)
    return nb_steps
45/52: count_steps(14)
45/53:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
    return nb_steps
45/54: count_steps(14)
45/55: count_steps(15)
45/56: count_steps(16)
45/57: count_steps(20)
45/58:
print(count_steps_p(15))
print(count_steps_m(15))
45/59:
import math
def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
    return nb_steps
45/60:
import math
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
    return nb_steps
45/61:
print(count_steps_p(15))
print(count_steps_m(15))
45/62:
print(count_steps_p(20))
print(count_steps_m(20))
45/63:
print(count_steps_p(21))
print(count_steps_m(21))
45/64:
import math
def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        x = n+1 # pour le plus
        y = n-1 # pour le moins
        nb_steps_p = nb_steps + count_steps(x)
        nb_steps_m = nb_steps + count_steps(y)
        return [nb_steps_p, nb_steps_m]
45/65:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        x = n+1 # pour le plus
        y = n-1 # pour le moins
        nb_steps_p = nb_steps + count_steps(x)
        nb_steps_m = nb_steps + count_steps(y)
        return [nb_steps_p, nb_steps_m]
45/66: print(count_steps(21))
45/67:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        x = n+1 # pour le plus
        y = n-1 # pour le moins
        nb_steps_p = nb_steps + count_steps(x)
        nb_steps_m = nb_steps + count_steps(y)
        return min(nb_steps_p, nb_steps_m)
45/68: print(count_steps(21))
45/69: print(count_steps(15))
45/70: print(count_steps(4))
45/71: print(count_steps(16))
45/72: print(count_steps(1))
45/73:
import math
def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + ccount_steps_p(n)
    return nb_steps
45/74:
import math
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps
45/75:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        x = n+1 # pour le plus
        y = n-1 # pour le moins
        nb_steps_p = nb_steps + count_steps_p(x)
        nb_steps_m = nb_steps + count_steps_m(y)
        return min(nb_steps_p, nb_steps_m)
45/76: print(count_steps(1))
45/77: print(count_steps(1))
45/78: print(count_steps(15))
45/79:
import math
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps
45/80:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        x = n+1 # pour le plus
        y = n-1 # pour le moins
        nb_steps_p = nb_steps + count_steps_p(x)
        nb_steps_m = nb_steps + count_steps_m(y)
        return min(nb_steps_p, nb_steps_m)
45/81: print(count_steps(15))
45/82:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return min(nb_steps_p, nb_steps_m)
45/83: print(count_steps(15))
45/84:
import math
def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
45/85:
import math
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps
45/86:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return min(nb_steps_p, nb_steps_m)
45/87: print(count_steps(15))
46/1:
import math
def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))
46/2:
def isodd(n):
     if (n % 2) != 0:
            return True
46/3:
def iseven(n):
     if (n % 2) == 0:
            return True
46/4:
import math
def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
46/5:
import math
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps
46/6:
import math
def count_steps(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return min(nb_steps_p, nb_steps_m)
46/7: print(count_steps(15))
46/8: print(count_steps(20))
46/9: print(count_steps(21))
46/10:
import math
def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return min(nb_steps_p, nb_steps_m)
46/11: print(count_steps("21"))
46/12:
import math
def solution(n):
    x = int(n)
    nb_steps = 0
    if x==1:
        return 0
    if isPowerof2(x):
        return math.log2(x)
    if iseven(x):
        x = x/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(x)
        return nb_steps
    if isodd(x):
        nb_steps_p = nb_steps + count_steps_p(x)
        nb_steps_m = nb_steps + count_steps_m(x)
        return min(nb_steps_p, nb_steps_m)
46/13: print(solution("21"))
46/14:
import math
def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return nb_steps
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return min(nb_steps_p, nb_steps_m)
46/15: print(solution("21"))
46/16: print(solution("15"))
46/17: print(solution("14"))
46/18: print(solution("7"))
46/19: print(solution("4"))
46/20: print(solution("15"))
46/21:
import math
def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
46/22: print(solution("15"))
47/1:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
47/2: solution('15')
47/3: solution('4')
47/4: solution('15')
47/5: solution('15')
47/6: print(solution('15'))
47/7: print(solution('4'))
46/23: solution(str(10**309 - 1))
46/24: solution("4")
46/25: solution("153")
46/26: solution("16")
46/27: solution("32")
46/28: solution("33")
46/29: solution("31")
46/30: solution("124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399")
46/31: solution("124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399")
48/1: print(solution('14'))
48/2:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
48/3: print(solution('14'))
48/4:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
48/5: print(solution('14'))
48/6:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + solution(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
48/7: print(solution('14'))
48/8: print(solution('15'))
48/9: print(solution('4'))
48/10: print(solution('15'))
48/11: print(solution('16'))
48/12: print(solution('32'))
48/13: print(solution('33'))
48/14: print(solution('31'))
48/15: print(solution('124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399'))
48/16:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + solution(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
48/17: print(solution('124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399'))
48/18: res = solution('124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399')
48/19: print(res)
49/1:
import math

def isPowerof2(n):
    return (math.ceil(math.log2(n)) == math.floor(math.log2(n)))

def isodd(n):
     if (n % 2) != 0:
            return True
            
def iseven(n):
     if (n % 2) == 0:
            return True

def count_steps_p(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
        return nb_steps
    if isodd(n):
        n = n+1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_p(n)
    return nb_steps
    
def count_steps_m(n):
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return math.log2(n)
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
        return nb_steps
    if isodd(n):
        n = n-1
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + count_steps_m(n)
    return nb_steps

def solution1(n):
    n = int(n)
    nb_steps = 0
    if n==1:
        return 0
    if isPowerof2(n):
        return int(math.log2(n))
    if iseven(n):
        n = n/2 
        nb_steps = nb_steps + 1
        nb_steps = nb_steps + solution(n)
        return int(nb_steps)
    if isodd(n):
        nb_steps_p = nb_steps + count_steps_p(n)
        nb_steps_m = nb_steps + count_steps_m(n)
        return int(min(nb_steps_p, nb_steps_m))
49/2:
def solution2(n):
    x = int(n)
    c = 0
    
    while x > 1:
        if x & 1 == 1:
            # x is odd
            if x % 4 == 1 or x==3:
                x -= 1
            else:
                x += 1
        else:
            # x is even
            x = x >> 1
        c += 1
    return c
49/3:
my_res=solution1('124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399')
his_res=solution2('124480579411363943422977485485450829978158403576349485507396127987323092328068524587695005561434534623452345436346456353425362283769712245781118297614280332424240701048410620648401132628401374562794562558123463462235342526466804149296501029546541499918765438784295157088047123009825235235168758962399')
49/4: print(my_res, his_res)
50/1:
import pandas as pd 
import numpy as np
50/2:
#To-Do: read the dataset 
data = read_csv("HepatitisCdata.csv")
50/3:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
50/4: data.info()
50/5:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
50/6: data.Category.unique
50/7: data.Category.unique()
50/8: data.Sex.unique()
50/9:
import pandas as pd 
import numpy as np
50/10:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
50/11: data.info()
50/12:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
50/13: data.Category.unique()
51/1:
import pandas as pd 
import numpy as np
51/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
51/3: data.info()
51/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
51/5: data.Category.unique()
51/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
51/7: data.Sex.unique()
51/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
51/9: data
51/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
51/11: data.columns
51/12: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
51/13: data.columns
51/14: # Don't forget to drop the index
51/15: data.isna.sum()
51/16: data.isna().sum()
51/17:
import matplotlib.pyplot as plt
import seaborn as sns
52/1:
import pandas as pd 
import numpy as np
52/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
52/3: data.info()
52/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
52/5: data.Category.unique()
52/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
52/7: data.Sex.unique()
52/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
52/9: data
52/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
52/11:
import matplotlib.pyplot as plt
import seaborn as sns
52/12: data.isna().sum()
52/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
52/14:
# Dropping the irrelevant columns
data.drop(['Unnamed: 0'],axis=1,inplace=True)
data.head()
52/15:
# Outliers Identification using Boxplot
sns.boxplot(data['ALB'],data=data)
sns.boxplot(data['ALP'],data=data)
sns.boxplot(data['ALT'],data=data)
sns.boxplot(data['CHOL'],data=data)
sns.boxplot(data['PROT'],data=data)
52/16:
Since they are outliers in all the previously plotted features, it is advised not to use the mean to replace missing values 
because it is highly susceptible to outliers. So replacement will be using either the median or the mode.
53/1:
import pandas as pd 
import numpy as np
53/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
53/3: data.info()
53/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
53/5: data.Category.unique()
53/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
53/7: data.Sex.unique()
53/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
53/9: data
53/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
53/11:
import matplotlib.pyplot as plt
import seaborn as sns
53/12: data.isna().sum()
53/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
53/14:
# Outliers Identification using Boxplot
sns.boxplot(data['ALB'],data=data)
53/15: sns.boxplot(data['ALP'],data=data)
53/16: sns.boxplot(data['ALT'],data=data)
53/17: sns.boxplot(data['CHOL'],data=data)
53/18: sns.boxplot(data['PROT'],data=data)
53/19:
print('skewness value of Age: ',data['ALB'].skew())
print('skewness value of Fare: ',data['ALP'].skew())
print('skewness value of Age: ',data['ALT'].skew())
print('skewness value of Age: ',data['CHOL'].skew())
print('skewness value of Age: ',data['PROT'].skew())
53/20: data.columns
53/21: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
53/22: data.columns
53/23: # Don't forget to drop the index
54/1:
import pandas as pd 
import numpy as np
54/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
54/3: data.info()
54/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
54/5: data.Category.unique()
54/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
54/7: data.Sex.unique()
54/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
54/9: data
54/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
54/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
54/12: data.isna().sum()
54/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
54/14:
# Outliers Identification using Boxplot
sns.boxplot(data['ALB'],data=data)
54/15: sns.boxplot(data['ALP'],data=data)
54/16: sns.boxplot(data['ALT'],data=data)
54/17: sns.boxplot(data['CHOL'],data=data)
54/18: sns.boxplot(data['PROT'],data=data)
54/19:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
54/20: data.columns
54/21: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
54/22: data.columns
54/23: # Don't forget to drop the index
54/24:
# Outliers Identification using Boxplot
sns.boxplot(data['ALB'],data=data).show()
54/25:
# Outliers Identification using Boxplot
sns.boxplot(data['ALB'],data=data)
54/26:
plt.rcParams["figure.figsize"] = [7.50, 3.50]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
54/27:
plt.rcParams["figure.figsize"] = [10, 10]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
54/28:
plt.rcParams["figure.figsize"] = [15, 4]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
54/29:
plt.rcParams["figure.figsize"] = [10, 4]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
54/30:
plt.rcParams["figure.figsize"] = [10, 4]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
plt.show()
54/31:
plt.rcParams["figure.figsize"] = [5, 10]
plt.rcParams["figure.autolayout"] = True
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
plt.show()
54/32:
plt.rcParams["figure.figsize"] = [5, 10]
plt.rcParams["figure.autolayout"] = False
ax = data[['ALB', 'ALP']].plot(kind='box', title='boxplot')
plt.show()
54/33:
ax = sns.boxplot(data[['ALB', 'ALP']], data=data)
plt.show()
54/34:
ax = sns.boxplot(data['ALB'], data=data)
plt.show()
54/35:
ax = sns.boxplot(data['ALB'], data['ALT'], data=data)
plt.show()
54/36:
fig, axes = plt.subplots(2, 2)
sns.boxplot(data=data, ax=axes[0,0])
54/37:
fig, axes = plt.subplots(2, 2)
sns.boxplot(data=data['ALP'], ax=axes[0,0])
54/38:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0,0])
54/39:
fig, axes = plt.subplots(2, 5)
sns.boxplot(data=data['ALP'], ax=axes[0,0])
54/40:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[1,1])
54/41:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[1])
54/42:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
54/43:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/44:
fig, axes = plt.subplots(1.5, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/45:
fig, axes = plt.subplots(2, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/46:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/47:
sns.set()
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/48:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/49:
fig, axes = plt.subplots(1, 5)
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/50:
fig, axes = plt.subplots(1, 5, figsize=(26,13))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/51:
fig, axes = plt.subplots(1, 5, figsize=(15,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
54/52:
fig, axes = plt.subplots(1, 5, figsize=(15,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[1])
sns.boxplot(data=data['CHOL'], ax=axes[1])
sns.boxplot(data=data['ALB'], ax=axes[1])
54/53:
fig, axes = plt.subplots(1, 5, figsize=(15,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/54:
fig, axes = plt.subplots(1, 5, figsize=(10,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/55:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/56:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/57:
fig, axes = plt.subplots(1, 5, figsize=(26,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/58:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/59:
fig, axes = plt.subplots(1, 5, figsize=(20,8))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/60:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot(data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/61:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot(data=data['ALP'], x='ALP', ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/62:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( x='ALP', data=data['ALP'], ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/63:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, x = 'ALP', ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/64:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot(data=data['ALT'], ax=axes[1])
sns.boxplot(data=data['PROT'], ax=axes[2])
sns.boxplot(data=data['CHOL'], ax=axes[3])
sns.boxplot(data=data['ALB'], ax=axes[4])
54/65:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[0])
sns.boxplot( data=data, y = 'PROT', ax=axes[0])
sns.boxplot( data=data, y = 'CHOL', ax=axes[0])
sns.boxplot( data=data, y = 'ALB', ax=axes[0])
54/66:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/67:
fig, axes = plt.subplots(5, 1, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/68:
fig, axes = plt.subplots(5, 1, figsize=(12,20))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/69:
fig, axes = plt.subplots(5, 1, figsize=(12,20))
sns.boxplot( data=data, y = 'ALP', ax=axes[0,0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/70:
fig, axes = plt.subplots(5, 1, figsize=(12,20))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/71:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0])
sns.boxplot( data=data, y = 'ALT', ax=axes[1])
sns.boxplot( data=data, y = 'PROT', ax=axes[2])
sns.boxplot( data=data, y = 'CHOL', ax=axes[3])
sns.boxplot( data=data, y = 'ALB', ax=axes[4])
54/72:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='skyblue')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='skyblue')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='skyblue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/73:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='yellow')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/74:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/75:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red', ax.text("hello"))
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/76:
fig, axes = plt.subplots(1, 5, figsize=(20,12))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/77:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/78:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/79:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/80:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
fig.set_yticklabels(['Red', 'Green', 'Blue'])
54/81:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/82:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red')
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
fig.set_ylabel("Y Label",fontsize=20)
54/83:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').sey_ylabel("helo")
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/84:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').set_ylabel("helo")
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/85:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').set_ylabel("ALP",fontsize=10)
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/86:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').set_ylabel("ALP",fontsize=20)
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/87:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').set_ylabel("ALP",fontsize=25)
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/88:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, y = 'ALP', ax=axes[0], color='red').set_ylabel("ALP",fontsize=15)
sns.boxplot( data=data, y = 'ALT', ax=axes[1], color='green')
sns.boxplot( data=data, y = 'PROT', ax=axes[2], color='orange')
sns.boxplot( data=data, y = 'CHOL', ax=axes[3], color='blue')
sns.boxplot( data=data, y = 'ALB', ax=axes[4], color='skyblue')
54/89:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data, ax=axes[0], color='red').set_ylabel("ALP",fontsize=15)
sns.boxplot( data=data, ax=axes[1], color='green').set_ylabel("ALT",fontsize=15)
sns.boxplot( data=data, ax=axes[2], color='orange').set_ylabel("PROT",fontsize=15)
sns.boxplot( data=data, ax=axes[3], color='blue').set_ylabel("CHOL",fontsize=15)
sns.boxplot( data=data, ax=axes[4], color='skyblue').set_ylabel("ALB",fontsize=15)
54/90:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data['ALP'], ax=axes[0], color='red').set_ylabel("ALP",fontsize=15)
sns.boxplot( data=data['ALT'], ax=axes[1], color='green').set_ylabel("ALT",fontsize=15)
sns.boxplot( data=data['PRPT'], ax=axes[2], color='orange').set_ylabel("PROT",fontsize=15)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_ylabel("CHOL",fontsize=15)
sns.boxplot( data=data['ALB'], ax=axes[4], color='skyblue').set_ylabel("ALB",fontsize=15)
54/91:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data['ALP'], ax=axes[0], color='red').set_ylabel("ALP",fontsize=15)
sns.boxplot( data=data['ALT'], ax=axes[1], color='green').set_ylabel("ALT",fontsize=15)
sns.boxplot( data=data['PROT'], ax=axes[2], color='orange').set_ylabel("PROT",fontsize=15)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_ylabel("CHOL",fontsize=15)
sns.boxplot( data=data['ALB'], ax=axes[4], color='skyblue').set_ylabel("ALB",fontsize=15)
54/92:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data['ALP'], ax=axes[0], color='red').set_xlabel("ALP",fontsize=15)
sns.boxplot( data=data['ALT'], ax=axes[1], color='green').set_xlabel("ALT",fontsize=15)
sns.boxplot( data=data['PROT'], ax=axes[2], color='orange').set_xlabel("PROT",fontsize=15)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=15)
sns.boxplot( data=data['ALB'], ax=axes[4], color='skyblue').set_xlabel("ALB",fontsize=15)
54/93:
fig, axes = plt.subplots(1, 5, figsize=(20,14))
sns.boxplot( data=data['ALP'], ax=axes[0], color='red').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALT'], ax=axes[1], color='green').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[2], color='orange').set_xlabel("PROT",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[4], color='skyblue').set_xlabel("ALB",fontsize=17)
54/94:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALP'], ax=axes[0], color='red').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALT'], ax=axes[1], color='green').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[2], color='orange').set_xlabel("PROT",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[4], color='skyblue').set_xlabel("ALB",fontsize=17)
54/95:
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
54/96:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
54/97:
data['ALP'] = data['ALP'].fillna(data['price'].median())
data['ALT'] = data['ALT'].fillna(data['price'].median())
data['PROT'] = data['PROT'].fillna(data['price'].median())
data['ALB'] = data['ALB'].fillna(data['price'].mode())
data['CHOL'] = data['CHOL'].fillna(data['price'].mode())
54/98:
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
data['ALB'] = data['ALB'].fillna(data['ALB'].mode())
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode())
54/99: data.isna().sum()
54/100:
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
data['ALB'] = data['ALB'].fillna(data['ALB'].mode())
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode())
54/101: data.isna().sum()
55/1:
import pandas as pd 
import numpy as np
55/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
55/3: data.info()
55/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
55/5: data.Category.unique()
55/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
55/7: data.Sex.unique()
55/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
55/9: data
55/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
55/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
55/12: data.isna().sum()
55/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
55/14:
# Outliers Identification using Boxplot
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
55/15:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
55/16:
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
data['ALB'] = data['ALB'].fillna(data['ALB'].mode())
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode())
55/17: data.isna().sum()
55/18: data.columns
55/19: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
55/20: data.columns
55/21: # Don't forget to drop the index
55/22:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode())
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode())
55/23: data.isna().sum()
55/24: data['CHOL'].mode()
55/25: data['CHOL'].median()
55/26: data['CHOL'].mode()
55/27:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode()[0])
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode()[0])
55/28: data.isna().sum()
56/1:
import pandas as pd 
import numpy as np
56/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
56/3: data.info()
56/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
56/5: data.Category.unique()
56/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
56/7: data.Sex.unique()
56/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
56/9: data
56/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
56/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
56/12: data.isna().sum()
56/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
56/14:
# Outliers Identification using Boxplot
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
56/15:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
56/16:
print("ALP median value: "+data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: "+data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: "+data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
56/17:
print("ALP median value: ", data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: "+data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: "+data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
56/18:
print("ALP median value: ", data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: ", data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: ", data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
56/19:
print("ALB modes are: ", data['ALB'].mode())

print("CHOL modes are: ", data['CHOL'].mode())
56/20:
#print("ALB modes are: ", data['ALB'].mode())

print("CHOL modes are: ", data['CHOL'].mode())
56/21:
print("ALB modes are: ", data['ALB'].mode())

print("CHOL modes are: ", data['CHOL'].mode())
56/22:
print("ALB mode value: \n", data['ALB'].mode())

print("CHOL modes are: \n", data['CHOL'].mode())
56/23:
print("ALB mode value: \n", data['ALB'].mode())
print()
print("CHOL modes are: \n", data['CHOL'].mode())
56/24:
print("ALB mode value: \n", data['ALB'].mode())
print()
print("CHOL modes are: \n",data['CHOL'].mode())
56/25:
print("ALB mode value: \n", data['ALB'].mode())
print()
print("CHOL modes are:\n",data['CHOL'].mode())
56/26:
print("ALB mode value:",data['ALB'].mode())
print()
print("CHOL modes are:\n",data['CHOL'].mode())
56/27:
print("ALB mode value:\n",data['ALB'].mode())
print()
print("CHOL modes are:\n",data['CHOL'].mode())
56/28:
print(data['ALB'].mode())
print()
print("CHOL modes are:\n",data['CHOL'].mode())
56/29:
print("ALB mode value:")
print(data['ALB'].mode())
print()
print("CHOL modes are:")
print(data['CHOL'].mode())
56/30:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode()[0])
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode()[0])
56/31: data.isna().sum()
56/32: data
57/1:
import pandas as pd 
import numpy as np
57/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
57/3: data.info()
57/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
57/5: data.Category.unique()
57/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
57/7: data.Sex.unique()
57/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
57/9: data
57/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
57/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
57/12: data.isna().sum()
57/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
57/14:
# Outliers Identification using Boxplot
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
57/15:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
57/16:
print("ALP median value: ", data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: ", data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: ", data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
57/17:
print("ALB mode value:")
print(data['ALB'].mode())
print()
print("CHOL modes are:")
print(data['CHOL'].mode())
57/18:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode()[0])
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode()[0])
57/19: data
57/20: data.isna().sum()
57/21: data.columns
57/22: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
57/23: data.columns
57/24:
# Don't forget to drop the index 
data.to_csv('clean_HepatitisCdata.csv',index=False)
58/1:
import pandas as pd 
import numpy as np
58/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
58/3: data.info()
58/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
58/5: data.Category.unique()
58/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
58/7: data.Sex.unique()
58/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
58/9: data
58/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
58/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
58/12: data.isna().sum()
58/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
58/14:
# Outliers Identification using Boxplot
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
58/15:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
58/16:
print("ALP median value: ", data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: ", data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: ", data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
58/17:
print("ALB mode value:")
print(data['ALB'].mode())
print()
print("CHOL modes are:")
print(data['CHOL'].mode())
58/18:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode()[0])
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode()[0])
58/19: data
58/20: data.isna().sum()
58/21: data.columns
58/22: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
58/23: data.columns
58/24:
# Don't forget to drop the index 
data.to_csv('clean_HepatitisCdata.csv',index=False)
58/25:
# Last check for the dataset values after changements, as well as the shape
data
59/1:
import pandas as pd 
import numpy as np
59/2:
#To-Do: read the dataset 
data = pd.read_csv("HepatitisCdata.csv")
59/3: data.info()
59/4:
#To-Do  Start investigating the data types and correcting that 
# Provide explanation about each step in Markdown cells 
data
59/5: data.Category.unique()
59/6:
data['Category'].replace(['0=Blood Donor', '0s=suspect Blood Donor','1=Hepatitis','2=Fibrosis','3=Cirrhosis'],
                         [0, 1, 2, 3, 4], inplace=True)
59/7: data.Sex.unique()
59/8: data['Sex'].replace(['m', 'f'],[0, 1], inplace=True)
59/9: data
59/10:
# To-Do Start providing solutions for each column that has missing data 
# Treat each case seperately 
# Hint : no data row should be deleted 
# Provide evidence that you filled those missing values after each step
59/11:
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")
59/12: data.isna().sum()
59/13:
# Visualizing the missing values
sns.heatmap(data.isnull(),yticklabels=False,cbar=False)
59/14:
# Outliers Identification using Boxplot
fig, axes = plt.subplots(1, 5, figsize=(20,10))
sns.boxplot( data=data['ALT'], ax=axes[0], color='red').set_xlabel("ALT",fontsize=17)
sns.boxplot( data=data['ALP'], ax=axes[1], color='green').set_xlabel("ALP",fontsize=17)
sns.boxplot( data=data['ALB'], ax=axes[2], color='orange').set_xlabel("ALB",fontsize=17)
sns.boxplot( data=data['CHOL'], ax=axes[3], color='blue').set_xlabel("CHOL",fontsize=17)
sns.boxplot( data=data['PROT'], ax=axes[4], color='skyblue').set_xlabel("PROT",fontsize=17)
59/15:
print('skewness value of ALB: ',data['ALB'].skew())
print('skewness value of ALP: ',data['ALP'].skew())
print('skewness value of ALT: ',data['ALT'].skew())
print('skewness value of CHOL: ',data['CHOL'].skew())
print('skewness value of PROT: ',data['PROT'].skew())
59/16:
print("ALP median value: ", data['ALP'].median())
data['ALP'] = data['ALP'].fillna(data['ALP'].median())
print("ALT median value: ", data['ALT'].median())
data['ALT'] = data['ALT'].fillna(data['ALT'].median())
print("PROT median value: ", data['PROT'].median())
data['PROT'] = data['PROT'].fillna(data['PROT'].median())
59/17:
print("ALB mode value:")
print(data['ALB'].mode())
print()
print("CHOL modes are:")
print(data['CHOL'].mode())
59/18:
data['ALB'] = data['ALB'].fillna(data['ALB'].mode()[0])
data['CHOL'] = data['CHOL'].fillna(data['CHOL'].mode()[0])
59/19:
# Last check for the dataset values after changements, as well as the shape
data
59/20: data.isna().sum()
59/21: data.columns
59/22: data.rename(columns={'Unnamed: 0': "ID"}, inplace=True)
59/23: data.columns
59/24:
# Don't forget to drop the index 
data.to_csv('clean_HepatitisCdata.csv',index=False)
60/1:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
60/2:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
60/3: df.head()
60/4:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
60/5:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
60/6: df.head()
60/7:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
60/8:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
60/9: df.head()
60/10:
# To-Do : We will select only the columns to work with = all columns except the id and the Category 
df.drop("ID", axis = 1, inplace=True)
60/11: df.drop("Category", axis = 1, inplace=True)
60/12: df.columns
60/13: df.columns.values
60/14: df.columns
60/15:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df. columns)
60/16:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df. columns)
n_clusters
60/17:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df. columns)
n_clusters
len(df.Category.unique())
60/18:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df.columns)
n_clusters
60/19:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
60/20:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
60/21: df.head()
60/22:
# To-Do : We will select only the columns to work with = all columns except the id and the Category 
cols = df.drop(["ID","Category"] axis=1, inplace=False)
60/23:
# To-Do : We will select only the columns to work with = all columns except the id and the Category 
cols = df.drop(["ID","Category"], axis=1, inplace=False)
60/24: cols
60/25: cols.values
60/26: cols.columns
60/27:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df.Category.unique())
60/28:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df.Category.unique())
n_clusters
60/29:
# define the model
model = AgglomerativeClustering(n_clusters=n_clusters)
60/30:
#To-Do : fit model and predict clusters
yhat = model.fit_predict(cols)
60/31:
# To-Do :Add the cluster as a column to the data frame 
df['cluster'] = yhat
60/32:
# To-Do :Add the cluster as a column to the data frame 
df['cluster'] = yhat
60/33:
# Checking the changement in the dataframe
df
61/1:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
61/2:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
61/3: df.head()
61/4:
# To-Do : We will select only the columns to work with = all columns except the id and the Category 
cols = df.drop(["ID","Category"], axis=1, inplace=False)
61/5: cols.columns
61/6:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df.Category.unique())
n_clusters
61/7:
# define the model
model = AgglomerativeClustering(n_clusters=n_clusters)
61/8:
#To-Do : fit model and predict clusters
yhat = model.fit_predict(cols)
61/9:
# To-Do :Add the cluster as a column to the data frame 
df['cluster'] = yhat
61/10:
# Checking the changement in the dataframe
df
61/11:
# To-Do save the file , Do not forget to drop the index 
df.to_csv("clustered_HepatitisCdata.csv")
62/1:
import pandas as pd 
from sklearn.cluster import AgglomerativeClustering
62/2:
# Load the dataset 
df = pd.read_csv("clean_HepatitisCdata.csv")
62/3: df.head()
62/4:
# To-Do : We will select only the columns to work with = all columns except the id and the Category 
cols = df.drop(["ID","Category"], axis=1, inplace=False)
62/5: cols.columns
62/6:
# To-Do: set the number of clusters to be equal to the number of classes ( categories)
n_clusters = len(df.Category.unique())
n_clusters
62/7:
# define the model
model = AgglomerativeClustering(n_clusters=n_clusters)
62/8:
#To-Do : fit model and predict clusters
yhat = model.fit_predict(cols)
62/9:
# To-Do :Add the cluster as a column to the data frame 
df['cluster'] = yhat
62/10:
# Checking the changement in the dataframe
df
62/11:
# To-Do save the file , Do not forget to drop the index 
df.to_csv("clustered_HepatitisCdata.csv", index = False)
65/1:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
65/2:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
65/3:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"])
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
65/4:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
65/5:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
65/6:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
65/7:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
65/8: data
65/9:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
65/10: X
65/11: Y
65/12:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
65/13:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
65/14:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
65/15:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
65/16:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
65/17:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
print(parameter_list)
65/18:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 
import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
65/19:
# Building Random Forest Classifier
rfc = RandomForestClassifier()
65/20:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': list(range(50, 500)), 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False]
    'max_depth': [list(range(10, 15)), None]
}]
score = ['accuracy', 'precision']
65/21:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': list(range(50, 500)), 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [list(range(10, 15)), None]
}]
score = ['accuracy', 'precision']
65/22:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': list(range(50, 500)), 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [list(range(10, 15)), None]
}]
score = ['accuracy', 'precision']
65/23:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params, scoring='%s_macro' % metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
65/24:
import warnings

warnings.filterwarnings("ignore")

gridSearch(X_train,Y_train,forest_params, score)
65/25:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train,Y_train,forest_params, score)
65/26:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score)
65/27:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score[0])
65/28:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params, scoring= metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
65/29:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score[0])
65/30:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [50, 70, 100, 150, 200, 250, 300, 400, 500], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [5, 10, 13 , 15, 18, 20, None]
}]
score = ['accuracy', 'precision']
65/31:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params, scoring= metric)
    clf.fit(X_train, y_train)
    print("Best parameters found ")
    print(clf.best_params_)
65/32:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score[0])
65/33:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params, scoring= metric)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
    print("Best score: ")
    print(clt.best_score_)
65/34:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score[0])
65/35:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params, scoring= metric)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
    print("Best score: ")
    print(clf.best_score_)
65/36:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params, score[0])
65/37:
# Building Random Forest Classifier
rfc = RandomForestClassifier()
65/38:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [100, 150, 200, 300, 400], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [10, 15, 20, 30, None]
}]
65/39:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params, metric):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
65/40:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
65/41:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters for %s " % metric)
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
65/42:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
65/43:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
65/44:
import warnings

warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
65/45: model = RandomForestClassifier(n_estimators=150,criterion='entropy',max_features="sqrt", max_depth= None, bootstrap: False)
65/46: model = RandomForestClassifier(n_estimators=150,criterion='entropy',max_features="sqrt", max_depth= None, bootstrap= False)
65/47: y_hat = model.predict(X_test)
65/48:
model = RandomForestClassifier(n_estimators=150,criterion='entropy',max_features="sqrt", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
65/49: y_hat = model.predict(X_test)
65/50:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score
print("Train score : \n")
y_train_pred = model.predict(X_train)
print("Accuracy :",accuracy_score(y_train,y_train_pred),"\n")
print("Precision :",precision_score(y_train,y_train_pred,average="macro"),"\n")
print("Test score :\n")
print("Accuracy score :",accuracy_score(y_test,y_hat),"\n")
print("Precision :",precision_score(y_test,y_hat,average="macro"),"\n")
65/51:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score
y_hat_train = model.predict(X_train)

print(f"Accuracy on Training set : {accuracy_score(Y_train,y_hat_train)}")
print(f"Precision on Training set : {precision_score(Y_train,y_hat_train,average='weighted')}")

print(f"Accuracy on Test set : {accuracy_score(Y_test,y_hat)} ")
print(f"Precision on Test set : {precision_score(Y_test,y_hat,average='weighted')}")
65/52:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score
y_hat_train = model.predict(X_train)

print(f"Accuracy on Training set : {accuracy_score(y_train,y_hat_train)}")
print(f"Precision on Training set : {precision_score(y_train,y_hat_train,average='weighted')}")

print(f"Accuracy on Test set : {accuracy_score(y_test,y_hat)} ")
print(f"Precision on Test set : {precision_score(y_test,y_hat,average='weighted')}")
65/53:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(Y_test,y_hat)}')
65/54:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
65/55:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print(f"Precision on Test set : ", precision_score(y_test,y_hat)
65/56:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat))
65/57:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
65/58:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
65/59:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well  
test_df = X
test_df["Category"] = Y
65/60: test_df.head()
65/61:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
65/62:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
65/63:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
65/64: data
65/65:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
65/66:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 

import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
65/67:
# Building Random Forest Classifier
rfc = RandomForestClassifier()
65/68:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [100, 150, 200, 300, 400], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [10, 15, 20, 30, None]
}]
65/69:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
65/70:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
65/71: X
65/72:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well  
test_df = pd.DataFrame(X_test,columns = df.columns[2:14])
test_df["Category"] = Y_test
65/73:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well  
test_df = pd.DataFrame(X_test,columns = df.columns[2:14])
test_df["Category"] = y_test
65/74: test_df.head()
65/75:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well 
test_df = X_test
test_df['Category'] = df['Category']
test_df['ID'] = df['ID']
test_df['cluster'] = df['cluster']
65/76: test_df.head()
65/77:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well 
test_df = X_test
test_df['ID'] = df['ID']
test_df['cluster'] = df['cluster']
test_df['Category'] = df['Category']
65/78: test_df.head()
65/79:
# To-Do : Add the predicted_class column 
test_df["Predicted_class"] = y_hat
65/80: test_df.head()
65/81: test_df.head(10)
65/82: test_df.head(15)
65/83: test_df.head()
65/84: test_df.head(8)
65/85: test_df.head()
65/86:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
68/1:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
68/2:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
68/3:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
68/4: data
68/5:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
68/6:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 

import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
68/7:
# Building Random Forest Classifier
rfc = RandomForestClassifier()
68/8:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [100, 150, 200, 300, 400], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [10, 15, 20, 30, None]
}]
68/9:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
68/10:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
68/11:
model = RandomForestClassifier(n_estimators=150,criterion='entropy',max_features="sqrt", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
68/12: y_hat = model.predict(X_test)
68/13:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
68/14:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
68/15:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well 
test_df = X_test
test_df['ID'] = df['ID']
test_df['cluster'] = df['cluster']
test_df['Category'] = df['Category']
68/16: test_df.head()
68/17:
# To-Do : Add the predicted_class column 
test_df["Predicted_class"] = y_hat
68/18: test_df.head()
68/19:
# Save the test set 
test_df.to_csv("test_summary.csv")
68/20:
model = RandomForestClassifier(n_estimators=150,criterion='gini',max_features="log2", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
68/21: y_hat = model.predict(X_test)
68/22:
model = RandomForestClassifier(n_estimators=150,criterion='gini',max_features="log2", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
68/23: y_hat = model.predict(X_test)
68/24:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/1:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/2:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
69/3:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
69/4: data
69/5:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
69/6:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 

import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
69/7:
# Building Random Forest Classifier
rfc = RandomForestClassifier()
69/8:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [100, 150, 200, 300, 400], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [10, 15, 20, 30, None]
}]
69/9:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
69/10:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
69/11:
model = RandomForestClassifier(n_estimators=150,criterion='gini',max_features="log2", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
69/12: y_hat = model.predict(X_test)
69/13:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/14:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
69/15:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well 
test_df = X_test
test_df['ID'] = df['ID']
test_df['cluster'] = df['cluster']
test_df['Category'] = df['Category']
69/16: test_df.head()
69/17:
# To-Do : Add the predicted_class column 
test_df["Predicted_class"] = y_hat
69/18: test_df.head()
69/19:
# Save the test set 
test_df.to_csv("test_summary.csv")
69/20:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/21:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
69/22:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
69/23: data
69/24:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
69/25:
model = RandomForestClassifier(n_estimators=150,criterion='gini',max_features="sqrt", max_depth= None, bootstrap= False)
model.fit(X_train,y_train)
69/26: y_hat = model.predict(X_test)
69/27:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/28:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
69/29:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/30:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
69/31:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
69/32: data
69/33:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
69/34:
model = RandomForestClassifier(n_estimators=150,criterion='gini',max_features="sqrt", max_depth= None, bootstrap= True)
model.fit(X_train,y_train)
69/35: y_hat = model.predict(X_test)
69/36:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/37:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
69/38:
# To-Do : create the complete test dataframe : it should contain all the feature column + the actual target and the ID as well 
test_df = X_test
test_df['ID'] = df['ID']
test_df['cluster'] = df['cluster']
test_df['Category'] = df['Category']
69/39: test_df.head()
69/40:
# To-Do : Add the predicted_class column 
test_df["Predicted_class"] = y_hat
69/41: test_df.head()
69/42:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/43:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
69/44:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
69/45:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
69/46:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
69/47: data
69/48:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
69/49:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 

import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
69/50:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [100, 180, 230, 300], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [5, 10, 15, 20, None]
}]
69/51:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
69/52:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
69/53:
model = RandomForestClassifier(n_estimators=100,criterion='entropy',max_features="log2", max_depth=15, bootstrap= False)
model.fit(X_train,y_train)
69/54: y_hat = model.predict(X_test)
69/55:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/56:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/57:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/58:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
69/59:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
69/60:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
   1:
from sklearn.ensemble import RandomForestClassifier
import pandas as pd 
from sklearn.model_selection import train_test_split
   2:
# To-Do:  load the data 
df = pd.read_csv("clustered_HepatitisCdata.csv")
df.head()
   3:
# To-Do : keep only the columns to be used : all features except ID, cluster 
# The target here is the Category column 
# Do not forget to split your data (this is a classification task)
# test set size should be 20% of the data 
data = df.drop(["ID", "cluster"], axis=1, inplace=False)
   4: data
   5:
X = data.iloc[:,1:]
Y = data.iloc[:, 0]
X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)
   6:
# To-do build the model and train it 
# note that you will be providing explanation about the hyper parameter tuning 
# So you will be iterating a number of times before getting the desired performance 

import inspect
a_signature = inspect.signature(RandomForestClassifier)
parameters = a_signature.parameters
parameter_list = list(parameters)
parameter_list
   7:
# Initializing GridSearchCV() object and fitting it with hyperparameters
forest_params = [{
    'n_estimators': [70, 130, 180, 230, 300], 
    'criterion': ["gini", "entropy"],
    'max_features': ["sqrt","log2"],
    'bootstrap': [True, False],
    'max_depth': [5, 12, 18, 20, None]
}]
   8:
from sklearn.model_selection import GridSearchCV

def grid_search(X_train, y_train, tuned_params):
    print("# Tuning hyper_parameters")
    clf = GridSearchCV(RandomForestClassifier(), tuned_params)
    clf.fit(X_train, y_train)
    print("Best parameters found: ")
    print(clf.best_params_)
   9:
import warnings
warnings.filterwarnings("ignore")

grid_search(X_train, y_train, forest_params)
  10:
model = RandomForestClassifier(n_estimators=180,criterion='gini',max_features="log2", max_depth=20, bootstrap= False)
model.fit(X_train,y_train)
  11: y_hat = model.predict(X_test)
  12:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="macro"))
  13:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="macro"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="weighted"))
  14:
# To-do : evaluate the model in terms of accuracy and precision 
# Provide evidence that your model is not overfitting 
from sklearn.metrics import precision_score, accuracy_score

y_hat_train = model.predict(X_train)
print("Accuracy on Training set : ", accuracy_score(y_train,y_hat_train))
print("Precision on Training set :", precision_score(y_train,y_hat_train, average="weighted"))

print("Accuracy on Test set : ", accuracy_score(y_test,y_hat))
print("Precision on Test set : ", precision_score(y_test,y_hat, average="weighted"))
  15:
from sklearn.metrics import classification_report

print(f'Classification report on test set : \n{classification_report(y_test,y_hat)}')
  16: %history -g -f filename
